<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exam Practice Quiz</title>
    <style>
      /* Basic styling */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 10px;
        background: #f9f9f9;
        color: #333;
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
      }
      header {
        text-align: center;
        margin-bottom: 20px;
      }
      .hidden {
        display: none;
      }
      .question-container {
        background: #fff;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .options {
        list-style: none;
        padding: 0;
      }
      .option {
        margin: 10px 0;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        cursor: pointer;
      }
      .flagged {
        background: #fff3cd;
        border: 1px solid #ffeeba;
      }
      .timer {
        font-size: 1.2em;
      }
      .nav-buttons {
        text-align: center;
      }
      @media (max-width: 600px) {
        body {
          font-size: 16px;
        }
        button {
          width: 100%;
          margin: 5px 0;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Exam Practice Quiz</h1>
    </header>
    <div class="container">
      <!-- Start Screen -->
      <div id="start-screen">
        <p>
          Enter the URL of the JSON Question Bank Hosted on GitHub Pages:
        </p>
        <input
          type="text"
          id="question-bank-url"
          placeholder="https://yourgithubpages.com/questionbank.json"
          style="width: 100%; max-width: 500px;"
        />
        <p>Select Mode:</p>
        <select id="mode-select" style="width: 100%; max-width: 300px;">
          <option value="timed">Timed Exam Mode</option>
          <option value="section">Section-Based Practice Mode</option>
        </select>
        <div id="section-select-container" class="hidden">
          <p>Select Section:</p>
          <select id="section-select" style="width: 100%; max-width: 300px;">
            <!-- Dynamically filled -->
          </select>
        </div>
        <button id="start-btn">Start Quiz</button>
        <div id="resume-section" class="hidden">
          <p>Saved progress found. Do you want to resume?</p>
          <button id="resume-btn">Resume</button>
          <button id="new-btn">Start New Quiz</button>
        </div>
      </div>

      <!-- Quiz Screen -->
      <div id="quiz-screen" class="hidden">
        <div id="top-bar">
          <span class="timer" id="timer">Time: 00:00</span>
          <span id="progress">Question 0/0</span>
        </div>
        <div class="question-container" id="question-container">
          <!-- Question content will be injected here -->
        </div>
        <div class="nav-buttons">
          <button id="prev-btn">Previous</button>
          <button id="flag-btn">Flag</button>
          <button id="next-btn">Next</button>
        </div>
        <div id="feedback"></div>
        <button id="submit-btn" class="hidden">Submit Quiz</button>
      </div>

      <!-- Summary Screen -->
      <div id="summary-screen" class="hidden">
        <h2>Quiz Summary</h2>
        <p id="score"></p>
        <button id="restart-btn">Restart Quiz</button>
      </div>
    </div>

    <script>
      // Immediately invoked function to prevent global namespace pollution.
      (function () {
        let quizData = {
          questions: [],
          currentIndex: 0,
          timerDuration: 0, // in seconds, set if timed mode
          remainingTime: 0,
          timerInterval: null,
          mode: "timed", // or "section"
          selectedSection: null,
          answers: [],
          flagged: {},
        };

        // Utility function to shuffle an array in place.
        function shuffle(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        // Save progress to localStorage.
        function saveProgress() {
          localStorage.setItem("quizProgress", JSON.stringify(quizData));
        }

        // Load progress from localStorage.
        function loadProgress() {
          const data = localStorage.getItem("quizProgress");
          return data ? JSON.parse(data) : null;
        }

        // Clear progress from localStorage.
        function clearProgress() {
          localStorage.removeItem("quizProgress");
        }

        // Format seconds into MM:SS.
        function formatTime(seconds) {
          const m = Math.floor(seconds / 60)
            .toString()
            .padStart(2, "0");
          const s = (seconds % 60).toString().padStart(2, "0");
          return m + ":" + s;
        }

        // Update UI for timer.
        function updateTimerUI() {
          const timerEl = document.getElementById("timer");
          timerEl.textContent = "Time: " + formatTime(quizData.remainingTime);
        }

        // Start the countdown timer.
        function startTimer() {
          updateTimerUI();
          quizData.timerInterval = setInterval(() => {
            quizData.remainingTime--;
            updateTimerUI();
            if (quizData.remainingTime <= 0) {
              clearInterval(quizData.timerInterval);
              finishQuiz();
            }
          }, 1000);
        }

        // Stop the timer if running.
        function stopTimer() {
          if (quizData.timerInterval) {
            clearInterval(quizData.timerInterval);
          }
        }

        // Load the question bank from a specified URL.
        function loadQuestionBank(url) {
          fetch(url)
            .then((response) => response.json())
            .then((data) => {
              // Assume data is an object with a "questions" array.
              quizData.questions = data.questions || [];

              // Setup sections if available.
              setupSections();

              // Randomize question order.
              shuffle(quizData.questions);

              // Randomize answer order for each question.
              quizData.questions.forEach((q) => {
                if (q.choices) {
                  shuffle(q.choices);
                }
              });

              // Reset tracking arrays.
              quizData.answers = new Array(quizData.questions.length).fill(null);
              quizData.flagged = {};
              quizData.currentIndex = 0;
              updateProgressUI();
              displayQuestion();

              // Start timer if in timed mode.
              if (quizData.mode === "timed") {
                // Use provided duration from JSON or default to 30 minutes.
                quizData.timerDuration = data.duration || 30 * 60;
                quizData.remainingTime = quizData.timerDuration;
                startTimer();
              }
              // Show quiz screen.
              document.getElementById("start-screen").classList.add("hidden");
              document.getElementById("quiz-screen").classList.remove("hidden");
              saveProgress();
            })
            .catch((err) => {
              alert("Error loading question bank: " + err);
            });
        }

        // Setup section selection based on available question categories.
        function setupSections() {
          const sectionSelect = document.getElementById("section-select");
          sectionSelect.innerHTML = "";
          let categories = new Set();
          quizData.questions.forEach((q) => {
            if (q.category) {
              categories.add(q.category);
            }
          });
          if (categories.size === 0) {
            document.getElementById("section-select-container").classList.add("hidden");
          } else {
            document.getElementById("section-select-container").classList.remove("hidden");
            categories.forEach((cat) => {
              const option = document.createElement("option");
              option.value = cat;
              option.textContent = cat;
              sectionSelect.appendChild(option);
            });
          }
        }

        // Filter questions by selected section (for section mode).
        function filterQuestionsBySection() {
          if (quizData.mode === "section") {
            const selectedSection = document.getElementById("section-select").value;
            quizData.selectedSection = selectedSection;
            quizData.questions = quizData.questions.filter(
              (q) => q.category === selectedSection
            );
            // Reset progress tracking.
            quizData.answers = new Array(quizData.questions.length).fill(null);
            quizData.flagged = {};
            quizData.currentIndex = 0;
            updateProgressUI();
          }
        }

        // Display the current question.
        function displayQuestion() {
          const qContainer = document.getElementById("question-container");
          qContainer.innerHTML = "";
          const index = quizData.currentIndex;
          const question = quizData.questions[index];
          if (!question) return;
          const questionTitle = document.createElement("h3");
          questionTitle.textContent =
            "Question " + (index + 1) + ": " + question.question;
          qContainer.appendChild(questionTitle);

          // Create answer options.
          const ul = document.createElement("ul");
          ul.className = "options";
          question.choices.forEach((choice) => {
            const li = document.createElement("li");
            li.className = "option";
            const label = document.createElement("label");
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = "option";
            radio.value = choice;
            if (quizData.answers[index] === choice) {
              radio.checked = true;
            }
            radio.addEventListener("change", () => {
              quizData.answers[index] = choice;
              // Immediately show feedback along with the explanation.
              showFeedback(question, choice);
              saveProgress();
            });
            label.appendChild(radio);
            label.appendChild(document.createTextNode(" " + choice));
            li.appendChild(label);
            ul.appendChild(li);
          });
          qContainer.appendChild(ul);

          // If already answered, show feedback.
          if (quizData.answers[index] != null) {
            showFeedback(question, quizData.answers[index]);
          }
          updateProgressUI();
        }

        // Provide immediate feedback for an answered question.
        function showFeedback(question, selectedChoice) {
          const feedbackDiv = document.getElementById("feedback");
          feedbackDiv.innerHTML = "";
          const correct = selectedChoice === question.correctAnswer;
          const msg = document.createElement("p");
          msg.style.fontWeight = "bold";
          if (correct) {
            msg.textContent = "Correct! " + (question.explanation || "");
            msg.style.color = "green";
          } else {
            msg.textContent = "Incorrect. " + (question.explanation || "");
            msg.style.color = "red";
          }
          feedbackDiv.appendChild(msg);
        }

        // Update the progress text.
        function updateProgressUI() {
          const progressEl = document.getElementById("progress");
          progressEl.textContent =
            "Question " + (quizData.currentIndex + 1) + " / " + quizData.questions.length;
        }

        // Navigate to the next question.
        function nextQuestion() {
          if (quizData.currentIndex < quizData.questions.length - 1) {
            quizData.currentIndex++;
            displayQuestion();
            saveProgress();
          }
        }

        // Navigate to the previous question.
        function prevQuestion() {
          if (quizData.currentIndex > 0) {
            quizData.currentIndex--;
            displayQuestion();
            saveProgress();
          }
        }

        // Toggle flagging for the current question.
        function toggleFlag() {
          const index = quizData.currentIndex;
          if (quizData.flagged[index]) {
            delete quizData.flagged[index];
            document.getElementById("flag-btn").textContent = "Flag";
          } else {
            quizData.flagged[index] = true;
            document.getElementById("flag-btn").textContent = "Unflag";
          }
          saveProgress();
        }

        // Finish the quiz and show the summary.
        function finishQuiz() {
          stopTimer();
          document.getElementById("quiz-screen").classList.add("hidden");
          document.getElementById("summary-screen").classList.remove("hidden");
          let score = 0;
          quizData.questions.forEach((q, idx) => {
            if (quizData.answers[idx] === q.correctAnswer) score++;
          });
          document.getElementById("score").textContent =
            "Your Score: " + score + " / " + quizData.questions.length;
          clearProgress();
        }

        // Event listeners.
        document.getElementById("start-btn").addEventListener("click", () => {
          const url = document.getElementById("question-bank-url").value.trim();
          if (!url) {
            alert("Please enter a valid URL for the question bank.");
            return;
          }
          quizData.mode = document.getElementById("mode-select").value;
          if (quizData.mode === "section") {
            loadQuestionBank(url);
            // Wait briefly then filter by the selected section.
            setTimeout(() => {
              filterQuestionsBySection();
              displayQuestion();
            }, 500);
          } else {
            loadQuestionBank(url);
          }
        });

        // Show/hide section selection on mode change.
        document.getElementById("mode-select").addEventListener("change", (e) => {
          if (e.target.value === "section") {
            document.getElementById("section-select-container").classList.remove("hidden");
          } else {
            document.getElementById("section-select-container").classList.add("hidden");
          }
        });

        document.getElementById("next-btn").addEventListener("click", nextQuestion);
        document.getElementById("prev-btn").addEventListener("click", prevQuestion);
        document.getElementById("flag-btn").addEventListener("click", toggleFlag);
        document.getElementById("submit-btn").addEventListener("click", finishQuiz);
        document.getElementById("restart-btn").addEventListener("click", () => {
          location.reload();
        });

        // Resume functionality if saved progress exists.
        const saved = loadProgress();
        if (saved && saved.questions && saved.questions.length > 0) {
          quizData = saved;
          document.getElementById("start-screen").classList.add("hidden");
          document.getElementById("resume-section").classList.remove("hidden");
          if (quizData.flagged[quizData.currentIndex]) {
            document.getElementById("flag-btn").textContent = "Unflag";
          } else {
            document.getElementById("flag-btn").textContent = "Flag";
          }
        }

        document.getElementById("resume-btn").addEventListener("click", () => {
          document.getElementById("resume-section").classList.add("hidden");
          document.getElementById("quiz-screen").classList.remove("hidden");
          displayQuestion();
          if (quizData.mode === "timed") {
            startTimer();
          }
        });

        document.getElementById("new-btn").addEventListener("click", () => {
          clearProgress();
          location.reload();
        });

        // Basic PWA Service Worker registration.
        if ("serviceWorker" in navigator) {
          const swCode = `
            const CACHE_NAME = 'quiz-app-cache-v1';
            const URLS_TO_CACHE = [location.href];
            self.addEventListener('install', event => {
              event.waitUntil(
                caches.open(CACHE_NAME).then(cache => {
                  return cache.addAll(URLS_TO_CACHE);
                })
              );
            });
            self.addEventListener('fetch', event => {
              event.respondWith(
                caches.match(event.request).then(response => {
                  return response || fetch(event.request);
                })
              );
            });
            self.addEventListener('activate', event => {
              event.waitUntil(
                caches.keys().then(cacheNames => {
                  return Promise.all(
                    cacheNames.map(cacheName => {
                      if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                      }
                    })
                  );
                })
              );
            });
          `;
          const blob = new Blob([swCode], { type: "text/javascript" });
          const swUrl = URL.createObjectURL(blob);
          navigator.serviceWorker
            .register(swUrl)
            .then(() => {
              console.log("Service Worker registered");
            })
            .catch((err) => {
              console.error("Service Worker registration failed:", err);
            });
        }
      })();
    </script>
  </body>
</html>
